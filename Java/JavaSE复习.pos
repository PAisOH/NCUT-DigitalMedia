{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"children":[{"parent":"root","children":[{"parent":"5d85ba2e5c2d","children":[{"parent":"db14ed5e986d","children":[{"parent":"80f7edd10fe4","children":[],"id":"1f10a2a419e1","title":"作用：管理Java文件、解决同名文件冲突"},{"parent":"80f7edd10fe4","children":[{"parent":"c35d7b4ed08b","children":[],"id":"9a8ac54f6814","title":"java.lang语言基础，Object、String，此包从JDK1.1之后默认导入"},{"parent":"c35d7b4ed08b","children":[],"id":"727646b34c89","title":"java.utl各种工具类，类集框架、List、Set、Map、Arrays"},{"parent":"c35d7b4ed08b","children":[],"id":"aaf03609ceec","title":"java.lang.reflect：Java反射编程包"},{"parent":"c35d7b4ed08b","children":[],"id":"87943aaed5b4","title":"java.sql:进行数据库开发的支持包"},{"parent":"c35d7b4ed08b","children":[],"id":"03f079b802af","title":"java&nbsp;.io：I/O编程开发包"}],"id":"c35d7b4ed08b","title":"常用系统包"},{"parent":"80f7edd10fe4","children":[{"parent":"a75fb83305da","children":[],"id":"92121a4c8a6d","title":"格式：package包名<br>注意： 一个源文件只能有一个<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;包名全部英文小写"}],"id":"a75fb83305da","title":"定义包<br>"}],"id":"80f7edd10fe4","title":"包"}],"id":"db14ed5e986d","title":"程序构成"},{"parent":"5d85ba2e5c2d","children":[{"parent":"2fa769bb652c","children":[{"parent":"dff7d9799df7","children":[{"parent":"6ebd0467f9ef","children":[{"parent":"bfa53a24fe92","children":[],"id":"68c5b5af206b","title":"整数用int，<br>日期、时间、内存或文件字节大小用long<br>编码转换、二进制流操作用byte"}],"id":"bfa53a24fe92","title":"整型：byte、short、int、long"},{"parent":"6ebd0467f9ef","children":[{"parent":"162fe0826c39","children":[],"id":"4cf3511bbccf","title":"float取值范围4字节即32位，精度7-8；<br>double取值范围8字节即64位，精度16-17"},{"parent":"162fe0826c39","children":[],"id":"bf11b3489d56","title":"精确计算：BigDecimal类，将浮点型转化为String类型，再计算"},{"parent":"162fe0826c39","children":[],"id":"c0412c79dafa","title":"实践中，一般只用double"}],"id":"162fe0826c39","title":"浮点型：double、float"}],"id":"6ebd0467f9ef","title":"数值型"},{"parent":"dff7d9799df7","children":[{"parent":"e089eab4a5af","children":[],"id":"d76371fd3f1b","title":"描述中文会用到，基本不用"}],"id":"e089eab4a5af","title":"字符型char"},{"parent":"dff7d9799df7","children":[],"id":"b2cbd863227b","title":"布尔型boolean"},{"parent":"dff7d9799df7","image":{"w":334,"h":225,"url":"https://cdn2.processon.com/61c80df4e4b053ea69c1aecf?e=1640504324&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:oCGVy7LVZPLQR0LTfNewT7PpDPQ="},"children":[],"id":"a7525601bf18","title":""},{"parent":"dff7d9799df7","image":{"w":229,"h":141,"url":"https://cdn2.processon.com/61c6bb7ee4b06e54532d45e5?e=1640417678&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:Fwo5vQhiqZV8WvzPsaTQl4faHiY="},"children":[],"id":"d1012ceaca1f","title":""}],"id":"dff7d9799df7","title":"基本数据类型"},{"parent":"2fa769bb652c","children":[{"parent":"c62c350c3e7f","children":[],"id":"f60316979daa","title":"数组、类、接口(默认值是null)"}],"id":"c62c350c3e7f","title":"引用数据类型"}],"collapsed":false,"id":"2fa769bb652c","title":"数据类型"},{"parent":"5d85ba2e5c2d","children":[{"parent":"ca791d0cc1ab","children":[{"parent":"0bc8f27f6f07","children":[],"id":"3ad5157a60fc","title":"前后自增、自减"},{"parent":"0bc8f27f6f07","children":[],"id":"2d7d296667fa","title":"byte/short进行运算自动转化为int，结果为int"},{"parent":"0bc8f27f6f07","children":[{"parent":"9f5504fcd87c","children":[],"id":"26ec916aca0c","title":"java浮点数0是无限接近0的数，故java因此定义"}],"id":"9f5504fcd87c","title":"整数(byte,short,int,long)/整数0：ArithmeticException<br>0/任意浮点数0：NAN(Not A Number)&nbsp;<br>其他类型或非/浮点数0：Infinity无穷大"},{"parent":"0bc8f27f6f07","children":[],"id":"50ed1e780209","title":"字符串拼接符(连接符): +"}],"id":"0bc8f27f6f07","title":"算术运算符"},{"parent":"ca791d0cc1ab","children":[{"parent":"ee15f8e6d5f0","children":[],"id":"dcd0925ba8ab","title":"=、+=、-=、*=、/=、%=<br>&amp;=与等<br>|=或等<br>^=异或等<br>&lt;&lt;=左移等<br>&gt;&gt;=右移等<br>&gt;&gt;&gt;=无符号右移等<br>"},{"parent":"ee15f8e6d5f0","children":[],"id":"1e00e633a0c1","title":"byte/short参与赋值运算，结果仍然是原类型"}],"id":"ee15f8e6d5f0","title":"赋值运算符"},{"parent":"ca791d0cc1ab","children":[{"parent":"3d69487d22e9","children":[{"parent":"101f93897026","children":[],"id":"16d699b93567","title":"instanceof：判断对象于实例的关系"}],"id":"101f93897026","title":"==、!= 、&gt;、&lt;、&gt;=、&lt;=、instanceof"},{"parent":"3d69487d22e9","children":[],"id":"6f2dc4d3aa1c","title":"返回boolean"}],"id":"3d69487d22e9","title":"关系(/比较)运算符"},{"parent":"ca791d0cc1ab","children":[{"parent":"e59993c2d509","children":[],"id":"a3c898c4f346","title":"&amp;与、|或 、!非 、^异或 、&amp;&amp;短路与(逻辑与)、 ||短路或(逻辑或)"}],"id":"e59993c2d509","title":"逻辑运算符"},{"parent":"ca791d0cc1ab","children":[{"parent":"0f077ebbe61e","children":[],"id":"a7e54b2418d9","title":"&amp;与、|或 、!非 、^异或、&lt;&lt;左移、&gt;&gt;右移、&gt;&gt;&gt;无符号右移、~取反&nbsp;"}],"id":"0f077ebbe61e","title":"位运算符"},{"parent":"ca791d0cc1ab","children":[{"parent":"327d94b7a700","children":[],"id":"9567915edd0f","title":"逻辑值 ? exp1 : exp2"}],"id":"327d94b7a700","title":"三目运算符(条件)"}],"collapsed":true,"id":"ca791d0cc1ab","title":"运算符"},{"parent":"5d85ba2e5c2d","note":"标识符：变量、常量、函数、语句块的名字","children":[{"parent":"509fc58ec611","children":[],"id":"0737011c1968","title":"不能以数字开头、不能有@%空格etc"},{"parent":"509fc58ec611","children":[],"id":"9038ee7ec10d","title":"不能直接用关键字、保留字"},{"parent":"509fc58ec611","children":[],"id":"0871b1354b65","title":"$不能在代码中出现"},{"parent":"509fc58ec611","children":[],"id":"3968922fd731","title":"命名要有意义，常采用驼峰命名法"}],"id":"509fc58ec611","title":"标识符"},{"parent":"5d85ba2e5c2d","children":[{"parent":"6f384a6e4c59","children":[],"id":"5ba22c8b516e","title":"访问权限修饰符：private、protected、public"},{"parent":"6f384a6e4c59","children":[],"id":"c0c616fbc599","title":"定义类、函数、变量修饰符：abstract、final、static、synchronized"},{"parent":"6f384a6e4c59","children":[],"id":"7271234c15ad","title":"定义类和类之间关系：extends、implements"},{"parent":"6f384a6e4c59","children":[],"id":"49ceea8ed396","title":"建立实例和引用实例：new、this、super、instanceof"},{"parent":"6f384a6e4c59","children":[],"id":"4613c7e04691","title":"处理异常：try、catch、finally、throw、throws"},{"parent":"6f384a6e4c59","children":[],"id":"789e55abc741","title":"其他：native、strictfp、transient、volatile、assert"},{"parent":"6f384a6e4c59","children":[],"id":"dab39ddf435d","title":"已经不使用但保留的关键字：goto、const"},{"parent":"6f384a6e4c59","children":[{"parent":"94c6f3bdd39b","children":[{"parent":"e480261f798c","children":[{"parent":"ec8aeed5d025","children":[{"parent":"1cf52739cbcf","children":[],"id":"cedbed1e0950","title":"定义时初始化"},{"parent":"1cf52739cbcf","children":[],"id":"6b3f3ce06ce2","title":"final成员变量可以正在构造块初始化，不能在静态块初始化"},{"parent":"1cf52739cbcf","children":[],"id":"31fa09f78af6","title":"final静态(static)成员变量可以在静态块初始化，不能在构造块初始化"}],"id":"1cf52739cbcf","title":"final变量必须初始化"},{"parent":"ec8aeed5d025","children":[],"id":"62bed2d93709","title":"final参数：该参数在这个函数中不允许修改"},{"parent":"ec8aeed5d025","children":[],"id":"55d11ed6f1a6","title":"final方法：不允许子类重写该方法，但可以使用"},{"parent":"ec8aeed5d025","children":[{"parent":"334f39c0148c","children":[],"id":"75c2c2b63108","title":"表示此类不能被继承，所有的方法都不能被重写。<br>但是final类的成员变量是可变的，要想使final类的成员变量不可改变，必须给成员变量增加final"}],"id":"334f39c0148c","title":"final类"}],"id":"ec8aeed5d025","title":"final：引用不可变"},{"parent":"e480261f798c","children":[],"id":"06e482010e36","title":"finally：无论是否出现异常，都要强制执行finally块"},{"parent":"e480261f798c","note":"在垃圾回收器执行时会调用被回收对象的finalize()方法，但是需要注意的是，一旦垃圾回收器准备释放对象占用的空间，将首先调用其finalize()方法,并且在下一次垃圾回收动作发生时，才会很正回收对象占用的内存（相当于在第一次垃圾回收时，给该对象一次存活的机会）","children":[],"id":"a6b0ebaad339","title":"finalize：Object类的垃圾回收方法"}],"id":"e480261f798c","title":"final、finally、finalize"}],"id":"94c6f3bdd39b","title":"辨析"}],"id":"6f384a6e4c59","title":"常见关键字"},{"parent":"5d85ba2e5c2d","children":[{"parent":"00de1d871cf0","children":[],"id":"659e5eb8dcba","title":"静态变量(类变量)：独立于方法外，用static修饰"},{"parent":"00de1d871cf0","children":[],"id":"c6f94b847ec8","title":"实例变量：独立于方法外，没有static修饰"},{"parent":"00de1d871cf0","children":[],"id":"377ed26ef65f","title":"局部变量：类方法中的"}],"collapsed":true,"id":"00de1d871cf0","title":"变量"},{"parent":"5d85ba2e5c2d","children":[],"id":"2fc1de4699de","title":"常量"},{"parent":"5d85ba2e5c2d","children":[],"id":"2452f7487812","title":"方法"},{"parent":"5d85ba2e5c2d","children":[{"parent":"510058de8e97","children":[],"id":"d5acf92a8abc","title":"普通代码块：定义在方法中的代码块（包括主方法中的，形如psvm(){ <b><font color=\"#b71c1c\">{}&nbsp;</font></b>} ）"},{"parent":"510058de8e97","children":[{"parent":"53ac34ccb300","children":[],"id":"210ab2915349","title":"构造块优于构造方法执行，每new一个新对象调用一次构造块"}],"id":"53ac34ccb300","title":"构造块：定义在类中不加任何修饰符的代码块"},{"parent":"510058de8e97","children":[{"parent":"a65b8ef42dd0","children":[{"parent":"77e2694abbdd","children":[],"id":"f34c0ee12e04","title":"何时使用该类(类加载)何时执行，先于构造块"}],"id":"77e2694abbdd","title":"非主类的静态代码块"},{"parent":"a65b8ef42dd0","children":[{"parent":"172aaf31dfe3","children":[],"id":"3589391d3f4c","title":"public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args){}"},{"parent":"172aaf31dfe3","children":[],"id":"6bc4f3f5d7fc","title":"先于主方法main执行，即在JVM启动时执行(编译时)"}],"id":"172aaf31dfe3","title":"主类(含有main方法的类)中的静态代码块"}],"id":"a65b8ef42dd0","title":"静态(代码)块：使用static关键字定义的代码块","summaries":[{"summary":true,"parent":"a65b8ef42dd0","children":[],"range":"0,1","style":{"lineType":"curve_complex","lineColor":"#bf1e1b","lineWidth":"1"},"id":"ed389a60d15d","title":"无论实例化多少对象，静态块只执行一次<br>静态块的主要作用是为static属性进行初始化"}]},{"parent":"510058de8e97","children":[{"parent":"504fd4c77e80","children":[],"id":"8b10b3ad0d81","title":"目的：解决JVM的设计，多线程执行的不确定性"},{"parent":"504fd4c77e80","children":[],"id":"b54715d4e549","title":"功能：让每个线程依次排队操作共享变量的功能，是其他并发容器的基础"}],"style":{"background-color":"rgb(255, 255, 255)","border-radius":"0px","color":"rgb(51, 51, 51)","border-width":"2px","border-color":"rgb(51, 51, 51)","border-style":"dashed"},"id":"504fd4c77e80","title":"同步代码块：使用synchronized关键字加上锁对象定义的代码块"}],"collapsed":true,"id":"510058de8e97","title":"代码块{}"}],"collapsed":false,"id":"5d85ba2e5c2d","title":"java语言基础"},{"parent":"root","children":[{"parent":"5cda03804583","children":[{"parent":"d7cfae8141f4","children":[],"id":"be0e9ae29f9c","title":"为什么需要：低耦合、高内聚"},{"parent":"d7cfae8141f4","children":[{"parent":"9f1f943085fe","children":[],"id":"b03e28f42cb3","title":"private：仅该类持有"},{"parent":"9f1f943085fe","children":[],"id":"929a79dcd3ef","title":"default(就是不写出来)：同一个包中的可以访问"},{"parent":"9f1f943085fe","children":[],"id":"02661b0f026c","title":"protected：同一个包中的可以访问，不同包中的子类可以访问"},{"parent":"9f1f943085fe","children":[],"id":"5ad8b1fc1be6","title":"public：都可以访问"},{"parent":"9f1f943085fe","image":{"w":353,"h":197,"url":"https://cdn2.processon.com/61c812b6e4b0e49c3113f2b8?e=1640505542&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:0fmr3nP3UGLuJDK-dNSJQDWCg_A="},"children":[],"id":"c56f29478db5","title":""}],"id":"9f1f943085fe","title":"怎么封装：利用访问权限修饰符描述方法体或属性"}],"id":"d7cfae8141f4","title":"封装"},{"parent":"5cda03804583","note":"子类从父类继承，子类是对父类的泛化","children":[{"parent":"379eaf75ad91","children":[{"parent":"1a8dea767e7b","children":[{"parent":"460ca3d8aff0","children":[{"parent":"1bffd235b7a4","children":[],"id":"96238d2db9f6","title":"super和this不能一个构造方法中同时存在"}],"id":"1bffd235b7a4","title":"继承规则：子类继承成不了，子类可以使用super调用(第一行代码)"},{"parent":"460ca3d8aff0","children":[],"id":"91ebd7a1c3eb","title":"构造过程：从父类开始构造，如早起穿衣服，先穿内部的后穿外面的"},{"parent":"460ca3d8aff0","children":[{"parent":"e8e94803d164","children":[],"id":"2b8c364b7e9a","title":"无参构造是开发者创建而定，默认构造函数式编译器生成"},{"parent":"e8e94803d164","children":[],"id":"e1ed12c4e763","title":"若开发者显式声明无参构造函数，编译器不会生成默认构造函数"},{"parent":"e8e94803d164","children":[],"id":"204fd98eade2","title":"开发者声明无参构造是为了对类初始化；编译器生成默认构造函数，是为了在JVM进行类加载时，顺利验证父类的数据信息"}],"id":"e8e94803d164","title":"默认构造函数与无参构造函数"}],"id":"460ca3d8aff0","title":"构造器constructor"},{"parent":"1a8dea767e7b","children":[],"id":"19ede1677ec5","title":"protected关键字：尽量对包外隐藏，但对子类允许访问"},{"parent":"1a8dea767e7b","children":[],"id":"7175d4b8a27c","title":"向上转型：new子类，在后面通过基类的方法调用"}],"id":"1a8dea767e7b","title":"Java中的继承体现"},{"parent":"379eaf75ad91","children":[{"parent":"92b7b8c21c44","children":[],"id":"fd1b1627ab90","title":"一个类没有使用extends关键字，则默认继承Object类"},{"parent":"92b7b8c21c44","children":[{"parent":"cf827edeeb06","children":[],"id":"eb4e27b31df4","title":"toString()"},{"parent":"cf827edeeb06","note":"比较的也是hashCode哈希代码值","children":[],"id":"0e33ad24bc06","title":"equals()：比较两个对象是否是同一个对象：按字符串形式返回对象相关消息"},{"parent":"cf827edeeb06","note":"hashcdoe 的目的是讓不同的資料有不同的索引值，而相同的資料索引值就相同","children":[],"id":"7e14104bce04","title":"hashCode()返回该对象的哈希代码值"},{"parent":"cf827edeeb06","children":[],"id":"3602f1a4295e","title":"getClass()获取当前所属的类信息"}],"id":"cf827edeeb06","title":"Java中每个类都可以使用Object的方法"}],"id":"92b7b8c21c44","title":"Object类：所有类的父类"},{"parent":"379eaf75ad91","children":[{"parent":"cbc891161e0f","children":[],"id":"94273ae30720","title":"修饰类：不允许继承"},{"parent":"cbc891161e0f","children":[],"id":"3b9f993411f9","title":"修饰方法：<br>不允许被子类重写，可以继承<br>不能修饰构造方法"},{"parent":"cbc891161e0f","children":[{"parent":"88030c2e8f30","children":[],"id":"31e25baf83a4","title":"方法内部的局部变量：试用装之前被初始化赋值即可"},{"parent":"88030c2e8f30","children":[],"id":"20e56e55936c","title":"类中成员变量：只能在定义或构造代码块、构造方法中进行初始化设置"},{"parent":"88030c2e8f30","children":[],"id":"3c9fa80af4ad","title":"基本数据类型变量：初始赋值后不可更改"},{"parent":"88030c2e8f30","children":[],"id":"e53c6b87e715","title":"引用类型变量：初始后不能指向另一个对象，但指向对象的内容可变"}],"id":"88030c2e8f30","title":"修饰变量：不允许修改<br>"},{"parent":"cbc891161e0f","children":[],"id":"303f6f99327a","title":"配合static使用"}],"id":"cbc891161e0f","title":"final关键字<br>"}],"id":"379eaf75ad91","title":"继承"},{"parent":"5cda03804583","children":[{"parent":"b740b317b2c4","note":"继承的表现就是多态","children":[{"parent":"2c7f005890f8","children":[],"id":"b92524ed0d4b","title":"继承"},{"parent":"2c7f005890f8","note":"可以不重写，但不重写，继承就没有意义了","children":[],"id":"e09a88b36f2d","title":"重写Override"},{"parent":"2c7f005890f8","children":[],"id":"77ee54ea39fd","title":"父类引用指向子类实例"},{"parent":"2c7f005890f8","children":[{"parent":"8d72e26ced44","children":[],"id":"af0c504e06fb","title":"不需要显示指定(即不需要在前面加上括号的声明)"},{"parent":"8d72e26ced44","note":"动态连接：可以调用父类定义、子类重写的方法\n\n子类一般功能比父类强大、独特，向上转型可以使用子类强大功能，又能抽取基类共性","children":[],"id":"683d6a4158d4","title":"好处：动态连接"}],"id":"8d72e26ced44","title":"向上转型Upcast"}],"id":"2c7f005890f8","title":"三个必要条件"},{"parent":"b740b317b2c4","children":[{"parent":"d05ac5cc61c6","children":[],"id":"fcba86634615","title":"Substitutability可替换性：对已存在代码具有可替换性"},{"parent":"d05ac5cc61c6","children":[],"id":"3ff54e7973cc","title":"extensibility可扩充性：新增加的子类不影响已存在类的很多特性"},{"parent":"d05ac5cc61c6","children":[],"id":"7065c1fdb793","title":"接口性：父类通过方法签名，向子类提供一个公共接口，有子类完善或重写它来实现"},{"parent":"d05ac5cc61c6","children":[],"id":"2ca6a4ff1828","title":"灵活性"},{"parent":"d05ac5cc61c6","children":[],"id":"3a24d6685e94","title":"简化性"}],"id":"d05ac5cc61c6","title":"好处"},{"parent":"b740b317b2c4","children":[{"parent":"9d5b04e53ad3","children":[],"id":"7c1354763a7e","title":"编译时多态(设计时多态)：方法重载，引用本类实例的覆写"},{"parent":"9d5b04e53ad3","note":"系统调用该方法的实例对应的类型来决定选择调用何种方法","children":[],"id":"79566af1d0df","title":"运行时多态：引用子类实例的覆写"}],"id":"9d5b04e53ad3","title":"分类"},{"parent":"b740b317b2c4","children":[{"parent":"a8f4d790a0c6","children":[{"parent":"01e2dfe376e6","children":[],"id":"cbb7e9ed461b","title":"子类重写了父类的一个方法，向上转型的父类引用调用该方法时调用子类方法"}],"id":"01e2dfe376e6","title":"动态链接（动态调用）"},{"parent":"a8f4d790a0c6","children":[{"parent":"5b597219f098","note":"一种说法：严格意义不属于多态\n重载的具体实现是：编译器根据不同的参数表，对同名函数的名称做修饰，然后这些同名函数就变成了不同的函数。对重载函数的调用，在编译期间就已经确定了，是静态的(注意！是静态的)，因此，重载和多态无关。\n真正和多态相关的是重写，当子类重写了父类中的函数后，父类的 指针，根据赋值给它不同的子类对象指针，动态的调用属于子类的该函数，这样在编译期间是无法确定的，只有在运行期间，才会把动态链接转变为直接引用（称为动态链接，详见JVM内存模型-栈帧）","children":[{"parent":"bc3961b635a0","children":[],"id":"16bac8f73706","title":"即同名函数"}],"id":"bc3961b635a0","title":"重载overload"},{"parent":"5b597219f098","children":[{"parent":"04668f514033","children":[],"id":"ddb21eb95120","title":"对象多态的核心"}],"id":"04668f514033","title":"覆盖(重写)override"}],"id":"5b597219f098","title":"方法的多态性"},{"parent":"a8f4d790a0c6","children":[{"parent":"fc70a60071c1","children":[{"parent":"1edf20af31be","children":[],"id":"3335afebc377","title":"必须类名声明abstract，含有<b>或没有</b>抽象方法"},{"parent":"1edf20af31be","children":[],"id":"69af04947ffd","title":"类名和抽象方法用abstract修饰"},{"parent":"1edf20af31be","children":[{"parent":"2fa915644591","children":[],"id":"d3711b6bf111","title":"abstract不能和final同时使用"},{"parent":"2fa915644591","note":"abstract方法必须被子类覆写，而private不能被继承，若在子类使用重载同名的方法，不算覆写","children":[],"id":"ca95ccb80393","title":"abstract不能和private同时使用"}],"id":"2fa915644591","title":"抽象类必须有子类，子类必须覆写或继续向下声明抽象类所有抽象方法"},{"parent":"1edf20af31be","children":[],"id":"63d5a50a16c2","title":"创建实例化对象，必须通过子类向上转型"},{"parent":"1edf20af31be","children":[{"parent":"6a80730a2a71","children":[],"id":"f7c1e147348e","title":"模板设计方法"},{"parent":"6a80730a2a71","children":[],"id":"caa38ce86ec9","title":"钩子方法"}],"id":"6a80730a2a71","title":"应用"}],"id":"1edf20af31be","title":"抽象类"},{"parent":"fc70a60071c1","note":"java通过抽象类只允许单继承，为弥补限制，采用一些方法解决(Cpp有强大的多继承，但带来了更大的麻烦。为规避风险，Java只允许单继承)","children":[{"parent":"4dd67c4442a8","children":[{"parent":"691d770bd9b1","children":[],"id":"3c1ce21e245a","title":"当既可以用抽象类和接口时，接口优先"},{"parent":"691d770bd9b1","children":[],"id":"7f4f44995762","title":"接口名前面使用前缀\"I\""},{"parent":"691d770bd9b1","children":[],"id":"8912291abf13","title":"接口中方法和属性不要加任何修饰符，保持代码简洁性"}],"id":"691d770bd9b1","title":"开发要点"},{"parent":"4dd67c4442a8","children":[],"id":"d53ef6bbae06","title":"定义：一个只含抽象方法和全局变量的集合，使用<b style=\"color: rgb(255, 0, 0);\">interface关键字</b><font color=\"#000000\">定义</font>"},{"parent":"4dd67c4442a8","children":[],"id":"651aa759760e","title":"好处：实现多继承"},{"parent":"4dd67c4442a8","children":[{"parent":"477d7a50ae1d","children":[],"id":"c9f454695778","title":"格式：接口名 对象名 = new&nbsp;子类名()"}],"id":"477d7a50ae1d","title":"接口实例化对象"},{"parent":"4dd67c4442a8","children":[{"parent":"8c4caee9ac32","children":[],"id":"79b662f6f14e","title":"只允许public权限"},{"parent":"8c4caee9ac32","children":[],"id":"c2e77645b456","title":"接口不能继承抽象类，抽象类可以实现接口"},{"parent":"8c4caee9ac32","children":[],"id":"43d37e480c18","title":"接口可以继承多个父接口"},{"parent":"8c4caee9ac32","children":[],"id":"325741bedcc7","title":"接口可以定义内部结构：：内部普通类、内部接口"}],"id":"8c4caee9ac32","title":"接口的限制"},{"parent":"4dd67c4442a8","children":[{"parent":"7867208f0389","children":[],"id":"9859815753c0","title":"定义操作标准"},{"parent":"7867208f0389","children":[],"id":"b40b6f42a1c5","title":"表示能力"},{"parent":"7867208f0389","children":[],"id":"b69640857aec","title":"在分布式开发之中暴露远程服务方法"}],"id":"7867208f0389","title":"接口的应用——三大核心应用环境"}],"id":"4dd67c4442a8","title":"接口"},{"parent":"fc70a60071c1","note":"核心：new什么，调用的方法是否被子类覆写","children":[{"parent":"59ed44a34197","children":[],"id":"5bcac451b24b","title":"格式：父类名&nbsp;父类对象&nbsp;=&nbsp;子类实例"},{"parent":"59ed44a34197","note":"假设一父类有n个子类，现某方法要接受子类的实例。若没有向上转型，就要定义n个方法接收不同子类对象","children":[],"id":"090caa35df5f","title":"作用：参数统一化"}],"id":"59ed44a34197","title":"向上转型"},{"parent":"fc70a60071c1","children":[{"parent":"db3cea13b9a8","children":[],"id":"96f143d50fce","title":"格式：子类名 子类对象&nbsp;=&nbsp;(子类)父类实例"},{"parent":"db3cea13b9a8","children":[],"id":"ea079d800109","title":"作用：父类需要调用子类的扩展方法"},{"parent":"db3cea13b9a8","children":[{"parent":"44409ef9dd51","children":[],"id":"84604d80d334","title":"否则，抛出ClassCastException类型转换异常(运行时异常)"}],"id":"44409ef9dd51","title":"前提：向下转型之前一定要向上转型"},{"parent":"db3cea13b9a8","children":[{"parent":"fb5c09558dc6","image":{"w":405,"h":149,"url":"https://cdn2.processon.com/61c97c04e4b0ee5c8d889cf4?e=1640598036&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:1aMoRerH_LaoIcFYyC0hy9GZCeo="},"children":[],"id":"5ea53a9db1f0","title":"解决方法：在强制转换前，使用<font color=\"#ff0000\">instanceof关键字</font>进行转型判断<br>&nbsp; 格式：引用名&nbsp;instanceof&nbsp;类名(return boolean)"}],"id":"fb5c09558dc6","title":"安全隐患：若程序员转换成一个和原本向上转型实例不相符的子类类型，会抛出ClassCastException"}],"id":"db3cea13b9a8","title":"向下转型"}],"id":"fc70a60071c1","title":"对象的多态性"},{"parent":"a8f4d790a0c6","note":"java只允许单继承，为弥补限制，采用一下方法(Cpp有强大的多继承，但带来了更大的麻烦。为规避风险，Java只允许单继承)","children":[],"id":"74e7bf388321","title":"java只允许单继承，为弥补限制，采用一下方法"}],"id":"a8f4d790a0c6","title":"Java中的体现"},{"parent":"b740b317b2c4","children":[{"parent":"e69ffbcb8eaa","image":{"w":244,"h":360,"url":"https://cdn2.processon.com/61c974bbe4b05215c2c6845a?e=1640596171&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:mWKSvGGnUE0gWgvHQ3RXQqMhgAU="},"children":[],"id":"16c2b849c53f","title":""}],"id":"e69ffbcb8eaa","title":"多态的表现：相同引用调用相同的方法，出现不同结果<br>"}],"id":"b740b317b2c4","title":"多态<br>Polymorphism"}],"collapsed":false,"id":"5cda03804583","title":"面向对象"},{"parent":"root","children":[{"parent":"339285b7c8ed","children":[{"parent":"9d74c68fd634","children":[],"id":"e6b991767e99","title":"完整类名java.lang.String"},{"parent":"9d74c68fd634","note":"1. 引用数据类型都在堆上开辟空间\n2. 只有String类可以直接赋值，其他的必须通过new，JDK对String类做了优化\n3. 不同String对象直接赋相同值，指向字符串对象池的同一块(JVM底层设计，目的减小开销)\n4. 构造方法会开辟两块内存空间，不仅有一块赋值后变成垃圾空间，也会对字符串共享产生问题","children":[{"parent":"25fd8bc53e5e","note":"","children":[{"parent":"7c723ea100ba","children":[],"id":"02fe8d95b9ad","title":"直接赋值：只会开辟一块堆内存空间，并且该字符串对象可以自动保存在对象池中供下次使用<br>"}],"id":"7c723ea100ba","title":"直接赋值，在堆上开辟空间"},{"parent":"25fd8bc53e5e","children":[{"parent":"8053d1f95414","children":[],"id":"23da5b1f8e25","title":"会开辟两块堆内存空间，其中一块成为垃圾空间，不会自动的保存在对象池中，可以使用intern()方法手工入池"}],"id":"8053d1f95414","title":"构造方法，new字符串"}],"id":"25fd8bc53e5e","title":"两种实例化方法"},{"parent":"9d74c68fd634","children":[{"parent":"3487b5766778","children":[],"id":"9537d07a3dd9","title":"CharAt(Index)：获取指定索引值的单个字符"},{"parent":"3487b5766778","children":[],"id":"31696778ff3d","title":"getBytes()：字符串转换成字节数组"},{"parent":"3487b5766778","children":[{"parent":"560264434d07","children":[],"id":"89d24da7089d","title":"==：是数值比较，引用对象比较的是引用地址数值"},{"parent":"560264434d07","note":"","children":[],"id":"50f0b155db66","title":"equals()：字符串内容比较，区分大小写"},{"parent":"560264434d07","children":[],"id":"20d874f9b86b","title":"equalsIgnoreCase()：不区分大小写的相等比较"},{"parent":"560264434d07","children":[],"id":"7f4bf1ba05ea","title":"compareTo()：返回两个字符串的差"}],"id":"560264434d07","title":"字符串比较"},{"parent":"3487b5766778","children":[{"parent":"99d184d9386f","children":[],"id":"15add888e5dd","title":"contains(String&nbsp;str)：判断目标字符串在源字符串是否存在"},{"parent":"99d184d9386f","children":[],"id":"f468e1fc66f6","title":"startsWith(String&nbsp;str)：判断字符串是否以指定字符串开始"},{"parent":"99d184d9386f","children":[],"id":"e06cbbb8a21a","title":"startsWith(String&nbsp;str,intdex)：从指定位置开始判断是否以指定的字符串开头"},{"parent":"99d184d9386f","children":[],"id":"419a5bdb20fd","title":"public&nbsp;boolean&nbsp;endsWith(String&nbsp;str)：判断是否以指定的字符串结尾"}],"id":"99d184d9386f","title":"字符串查找"},{"parent":"3487b5766778","children":[],"id":"2fd6d2a2b5b9","title":"字符串部分拆分<br>public&nbsp;String[]&nbsp;split(String&nbsp;regex,int&nbsp;limit);<br>拆分后数组的长度为limit"},{"parent":"3487b5766778","children":[],"id":"a76d3057e29b","title":"&nbsp;public&nbsp;String&nbsp;substring&nbsp;(int&nbsp;beginIndex)从指定位置截取到文件末尾"},{"parent":"3487b5766778","children":[],"id":"40c4252e60c3","title":"public&nbsp;String&nbsp;trim()：去掉左右空格，保留中间空格<br>"},{"parent":"3487b5766778","children":[],"id":"03856aa59ef5","title":"etc..."}],"collapsed":true,"id":"3487b5766778","title":"常用方法"},{"parent":"9d74c68fd634","children":[],"id":"a45b9411b59f","title":"字符串常量：是String类的匿名对象"},{"parent":"9d74c68fd634","children":[],"id":"3afa52f8142d","title":"字符串常量一旦定义不可变更"}],"id":"9d74c68fd634","title":"String"},{"parent":"339285b7c8ed","children":[{"parent":"caa900424188","children":[],"id":"01e499c5b9b8","title":"目的：解决字符串不能修改的问题"},{"parent":"caa900424188","children":[],"id":"bccd260c2db1","title":"改变：String中使用\"+\"进行链接，StringBuffer使用append()"},{"parent":"caa900424188","children":[{"parent":"0075c4f34752","children":[],"id":"e531f0f8d498","title":"字符串反转：public&nbsp;synchronized&nbsp;StringBuffer&nbsp;reverse()"},{"parent":"0075c4f34752","children":[],"id":"5a631aa13bfe","title":"删除指定范围的数据：public&nbsp;synchronized&nbsp;StringBuffer&nbsp;delete(int&nbsp;start,int&nbsp;end)"},{"parent":"0075c4f34752","children":[],"id":"938144f17502","title":"插入数据(在offset之前插入)：public&nbsp;synchronized&nbsp;StringBuffer&nbsp;insert(int&nbsp;offset,各种数据类型&nbsp;b)"}],"id":"0075c4f34752","title":"常用方法"},{"parent":"caa900424188","children":[],"id":"7bc934cd86e7","title":"StringBuilder和StringBuffer方法、一模一样"},{"parent":"caa900424188","children":[{"parent":"e6cb6ad2592e","children":[],"id":"0714e10d82af","title":"String的内容不可修改，StringBuffer和StringBuilder的内容可以修改"},{"parent":"e6cb6ad2592e","children":[],"id":"c87f8d70f40f","title":"StringBuffer采用同步处理，线程安全，效率低"},{"parent":"e6cb6ad2592e","children":[],"id":"8085d07aa512","title":"StringBuilder使用异步处理，线程不安全，效率较高"},{"parent":"e6cb6ad2592e","children":[],"id":"6445f5b176e2","title":"在普遍场景下，推荐使用StringBuilder，当String对象使用\"+\"进行字符串拼接时，javac编译器会将String对象变为StringBuilder而后调用append()来修改字符串的内容减少无用空间的开辟"}],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","border-width":"0px","border-color":"rgb(255, 255, 255)","border-style":"none"},"id":"e6cb6ad2592e","title":"比较String、StringBuffer、StringBuilder"}],"id":"caa900424188","title":"StringBuffer"},{"parent":"339285b7c8ed","children":[{"parent":"0d57a60ce7dc","children":[],"id":"00866014f404","title":"作用：java是完全面向对象的编程语言，而基本数据竟然不是面向对象的，<br>故提出包装类，将基本类型封装到类中，方便一些基本操作"},{"parent":"0d57a60ce7dc","children":[{"parent":"36c5766e6a89","children":[],"id":"be754d1fd8ec","title":"数值型包装类Number的子类：Byte、Short、Integer、Long、Float、Double"},{"parent":"36c5766e6a89","children":[],"id":"064edb413a45","title":"对象型包装类：Boolean、Character"}],"id":"36c5766e6a89","title":"类型"},{"parent":"0d57a60ce7dc","children":[{"parent":"1e154f3832ed","children":[],"id":"44176bb27281","title":"装箱：将基本数据类型变成包装类对象，通过每个包装类的构造方法实现"},{"parent":"1e154f3832ed","children":[],"id":"2c9e9e70e781","title":"拆箱：将包装类中包装的基本数据类型取出，利用的是××Value()方法"}],"id":"1e154f3832ed","title":"装箱与拆箱"},{"parent":"0d57a60ce7dc","note":"JDK1.5新特性","children":[],"id":"dbda3b1d9723","title":"自动拆装箱(语法糖)"},{"parent":"0d57a60ce7dc","children":[{"parent":"e188daec072f","children":[],"id":"492088d134eb","title":"boolean：true和false&nbsp;<br>byte：-128～127&nbsp;<br><b>char：0～127&nbsp;</b><br>short：-128～127&nbsp;<br>int：-128～127&nbsp;<br>long：-128～127<br>float、double无缓存池"}],"id":"e188daec072f","title":"缓存池"},{"parent":"0d57a60ce7dc","children":[{"parent":"fe2d35f4e86e","note":"POJO：简单Java类，即类中只有属性和getter、setter、构造方法","children":[],"id":"a33573fb5d6f","title":"所有POJO类强制使用包装类"},{"parent":"fe2d35f4e86e","children":[],"id":"9d3ea26155aa","title":"局部变量推荐使用基本类型"}],"id":"fe2d35f4e86e","title":"使用时机"},{"parent":"0d57a60ce7dc","children":[{"parent":"7300c34c19bf","note":"String str =&quot;124&quot;;\nint i = Integer.parseInt(str);","children":[],"id":"332c8949f4c2","title":"String to&nbsp;基本：使用 包装类名.parse(近似)包装类名(str)"},{"parent":"7300c34c19bf","children":[{"parent":"e5c06dbb08cd","note":"JVM会转化成StringBuilder执行append操作","children":[],"id":"217e119fcfd7","title":"\"+\"：任何数据类型 +&nbsp;字符串&nbsp;都会变成字符串"},{"parent":"e5c06dbb08cd","children":[],"id":"76fe55ef2a60","title":"通过String的构造方法"},{"parent":"e5c06dbb08cd","children":[],"id":"4f732c50998a","title":"String.valueOf(基本)"}],"id":"e5c06dbb08cd","title":"基本&nbsp;to&nbsp;String"}],"id":"7300c34c19bf","title":"String和基本数据类型转换"}],"id":"0d57a60ce7dc","title":"包装类<br>Wrapper&nbsp;Class"},{"parent":"339285b7c8ed","children":[{"parent":"710a824986ab","image":{"w":253,"h":225,"url":"https://cdn2.processon.com/61cc1146e4b0eff8b46cefc5?e=1640767318&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:ao-dps-5I7mAzNZrTIVUe3cyHS4="},"children":[],"id":"9ebe222ab7dc","title":"框架体系"},{"parent":"710a824986ab","children":[],"id":"d0c5af70fb81","title":"集合接口"}],"id":"710a824986ab","title":"集合框架"}],"collapsed":false,"id":"339285b7c8ed","title":"常用类"},{"parent":"root","children":[],"id":"3cb5ed9322d3","title":"泛型"},{"parent":"root","note":"Graphical User Interface，即图形用户界面\nJava中针对GUI设计提供了丰富的类库，这些类分别位于java.awt和javax.swing包中，简称为AWT和Swing","children":[{"parent":"2393995fa75b","children":[{"parent":"b0e442d669ee","children":[{"parent":"5073cf4db099","children":[{"parent":"abd840704b54","children":[],"id":"e39c32ac9358","title":"基本组件类：按钮、文本框之类的图形界面元素"},{"parent":"abd840704b54","children":[{"parent":"80f76031edfb","children":[{"parent":"71772bf176ce","children":[],"id":"74cd58896c71","title":"主界面Frame具有标题栏的框架窗口子类"},{"parent":"71772bf176ce","children":[],"id":"756484406e45","title":"Dialog实现信息交互的对话框子类"}],"id":"71772bf176ce","title":"Window不依赖其它容器而独立存活的容器"},{"parent":"80f76031edfb","children":[{"parent":"610e011e14db","children":[],"id":"a6bc8c741a82","title":"一个Panel对象代表一个长方形区域，一般通过Panel实现一些特殊布局"}],"id":"610e011e14db","title":"Panel只能存在其他容器(Window及其子类)中"}],"id":"80f76031edfb","title":"Container容器类：通过Component的子类Container实例化的对象<br>其中，Container是特殊的组件，可以容纳其他组件"}],"id":"abd840704b54","title":"组件Component除菜单外"},{"parent":"5073cf4db099","children":[],"id":"736f2142bfa6","title":"MenuComponent菜单相关"}],"id":"5073cf4db099","title":"AWT组件"},{"parent":"b0e442d669ee","note":"组件在容器中的位置和尺寸是由布局管理器来决定的\n\n每个容器在创建时都会有一种默认的布局管理器，在程序中可以调用容器对象的setLayout（）方法设置布局管理器，通过布局管理器来自动进行组件的布局管理","children":[{"parent":"6794122ffd9c","children":[{"parent":"0fc75bf2a4c9","image":{"w":123,"h":78,"url":"https://cdn2.processon.com/61cc1669e4b0503c66864a27?e=1640768633&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:hzzGWxJPfMaveMIfvfjz_N6_CQ4="},"children":[],"id":"fd3238566325","title":""}],"id":"0fc75bf2a4c9","title":"FlowLayout（流式布局管理器）:将组件按照添加顺序从左向右放置，当容器到达边界时，会自动将组件放到下一行的开始位置，这些组件可以左对齐、居中对齐（默认对齐）、或右对齐的方式排列"},{"parent":"6794122ffd9c","children":[{"parent":"a2f529d0b952","image":{"w":142,"h":147,"url":"https://cdn2.processon.com/61cc165fe4b0fb8e4fff64fe?e=1640768623&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:EpRXMg-KZSjySX0T_cxnMWKcbCY="},"children":[],"id":"205c54a1c2a7","title":""}],"id":"a2f529d0b952","title":"Border&nbsp;Layout（边界布局管理器）:东（EAST）、南（SOUTH）、西（WEST）、北（NORTH）、中（CENTER）"},{"parent":"6794122ffd9c","children":[{"parent":"ec8cbf605ee9","image":{"w":152,"h":90,"url":"https://cdn2.processon.com/61cc1658e4b07db3fb5f1ac1?e=1640768616&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:cw5nCfezlvR5xZFMIFExXk9fqwE="},"children":[],"id":"84ac62a77879","title":""}],"id":"ec8cbf605ee9","title":"GridLayout（网格布局管理器）:用纵横线将容器分为n行m列大小相等的网络，每个网格中放置一个组件。添加到容器中的组件首先放置在第一行第一列（左上角）的网格中，然后在第一行的网格中从左至右依次放置其它组件。组件大小相同"},{"parent":"6794122ffd9c","children":[{"parent":"2a44eb60c5df","image":{"w":219,"h":124,"url":"https://cdn2.processon.com/61cc164fe4b02cfb43cc9ef1?e=1640768607&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:RUkEP311tgHTelz-J9W9F2Jn5zM="},"children":[],"id":"21077e8ccb89","title":""}],"id":"2a44eb60c5df","title":"GridBagLayout（网格包布局管理器）:允许组件大小各有不同，而且允许一个组件跨越一个或者多个网格"},{"parent":"6794122ffd9c","children":[{"parent":"bc06519796d5","image":{"w":237,"h":133,"url":"https://cdn2.processon.com/61cc1645e4b0bb21ed0fa4fe?e=1640768597&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:wbJ0Ddh0Y5XNcWabIfv4t1iqE7E="},"children":[],"id":"6bd534442191","title":""}],"id":"bc06519796d5","title":"CardLayout（卡片布局管理器）：卡片布局管理器将界面看做是一系列卡片，在任何时候只要其中一张卡片是可见的，这张卡片占据容器的整个区域"}],"id":"6794122ffd9c","title":"布局管理器"}],"id":"b0e442d669ee","title":"AWT"},{"parent":"2393995fa75b","children":[],"id":"86bd25467f71","title":"Swing"}],"collapsed":false,"id":"2393995fa75b","title":"GUI"},{"parent":"root","children":[{"parent":"0cce82b87c8b","children":[{"parent":"28266088d990","children":[{"parent":"e25305415b11","children":[],"id":"c35f46d66be8","title":"VirtualMachineError虚拟机错误"},{"parent":"e25305415b11","children":[],"id":"77b91058e512","title":"OutOfMemoryError内存溢出"},{"parent":"e25305415b11","children":[],"id":"586c1e3f08d5","title":"ThreadDeath线程死锁"}],"id":"e25305415b11","title":"Error"},{"parent":"28266088d990","children":[{"parent":"c69c0af4563c","children":[{"parent":"0a65abfd46ec","children":[],"id":"794c838e5c39","title":"NullPointerException"},{"parent":"0a65abfd46ec","children":[],"id":"796119e56f2d","title":"ArrayIndexOutOfBoundsException"},{"parent":"0a65abfd46ec","children":[],"id":"13b7a2a72fb3","title":"ArithmeticException"},{"parent":"0a65abfd46ec","children":[],"id":"34185e0ff333","title":"ClassCastException"}],"id":"0a65abfd46ec","title":"RuntimeExecption"},{"parent":"c69c0af4563c","children":[],"id":"34498f87216f","title":"IOException"},{"parent":"c69c0af4563c","children":[],"id":"8beeaf5ec886","title":"SQLException"}],"id":"c69c0af4563c","title":"Exception"}],"id":"28266088d990","title":"Throwable"}],"id":"0cce82b87c8b","title":"异常处理"},{"parent":"root","note":"https://blog.csdn.net/zhao_miao/article/details/98787679\n","children":[{"parent":"d78dbc0fbe1e","note":"1. 创建一个进程的开销比创建一个线程的开销大得多\n2. 进程之间通信比线程之间通信复杂的多","children":[{"parent":"8484fa6c538b","children":[],"id":"61ec5076bb34","title":"进程:&nbsp;操作系统中程序的一次执行周期（比如登录QQ到退出QQ就伴随着一个进程的创建与销毁）是资源分配的最小单位"},{"parent":"8484fa6c538b","children":[],"id":"2b90a75f6b8a","title":"线程:线程是进程的一个子任务，是任务分配的最小单位"}],"id":"8484fa6c538b","title":"进程与线程"},{"parent":"d78dbc0fbe1e","children":[{"parent":"0797f54fa0ec","children":[],"id":"8211e35330e7","title":"继承Thread类，覆写run()，用start()启动"},{"parent":"0797f54fa0ec","children":[],"id":"8bd3e0777b6a","title":"实现Runnable接口，覆写run()，用start()启动"},{"parent":"0797f54fa0ec","children":[{"parent":"14e5e08eb688","children":[],"id":"93baa77b2b4f","title":"return"}],"id":"14e5e08eb688","title":"实现Callable接口，覆写call()方法"}],"id":"0797f54fa0ec","title":"线程创建方式"},{"parent":"d78dbc0fbe1e","children":[{"parent":"2388bccf20df","children":[{"parent":"dd10940c01a5","note":"对于小作业，创建一个线程所耗费的资源和时间极有可能大于作业的实际处理时间","children":[],"id":"0efa9dcce9ce","title":"重复利用已创建的线程，降低线程创建与销毁带来的损耗&nbsp;"},{"parent":"dd10940c01a5","children":[],"id":"3a1f79180d33","title":"统一进行线程分配、调度和监控"}],"id":"dd10940c01a5","title":"存在原因"},{"parent":"2388bccf20df","children":[{"parent":"f54a74c64459","image":{"w":317,"h":148,"url":"https://cdn2.processon.com/61cc0134e4b066edc7c7fded?e=1640763204&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:8rOvSzJ060QUPtasgts90C5bqug="},"children":[],"id":"749a473555cd","title":""}],"style":{"background-color":"rgb(255, 255, 255)","border-radius":"0px","color":"rgb(51, 51, 51)","border-width":"2px","border-color":"rgb(51, 51, 51)","border-style":"dashed"},"id":"f54a74c64459","title":"继承关系"},{"parent":"2388bccf20df","children":[{"parent":"a3b292e3eb1c","children":[{"parent":"3ffa4e958017","children":[],"id":"5aa37a0ed66a","title":"2.&nbsp;没有达到，创建一个线程执行任务"},{"parent":"3ffa4e958017","children":[{"parent":"092d29d4b49b","children":[],"id":"e4bf7dfa2e11","title":"3. 有空闲线程，交给空闲线程处理"},{"parent":"092d29d4b49b","children":[{"parent":"c8d9a53e3c3d","children":[],"id":"750632050d22","title":"4. 没有满，将当前线程放入阻塞队列"},{"parent":"c8d9a53e3c3d","children":[{"parent":"0236331c8312","children":[],"id":"fa0cd032b8bb","title":"5.&nbsp;没达到，创建线程执行任务"},{"parent":"0236331c8312","children":[{"parent":"93f4851e14fb","children":[],"id":"429c0bbdc20f","title":"JVM默认：AbortPolicy，即丢弃、抛出异常"},{"parent":"93f4851e14fb","children":[],"id":"0947af05abf9","title":"直接丢弃，也不抛出异常"},{"parent":"93f4851e14fb","children":[],"id":"bf9acc17e6ae","title":"等待调用者空闲后处理此任务"},{"parent":"93f4851e14fb","children":[{"parent":"f51b158edb30","children":[],"id":"341dec77e957","title":"ArrayBlockingQueue&nbsp;基于数组的有界阻塞队列"},{"parent":"f51b158edb30","children":[],"id":"9884d0c51266","title":"LinkedBlockingQueue&nbsp;基于链表的无界阻塞队列"},{"parent":"f51b158edb30","children":[],"id":"c79a35e85343","title":"SynchronousQueue&nbsp;不存储元素的无界阻塞队列"},{"parent":"f51b158edb30","children":[],"id":"d763a33874b6","title":"PriorityBlockingQueue&nbsp;基于优先级的无界阻塞队列"}],"id":"f51b158edb30","title":"丢掉阻塞队列最近的一个任务，并执行新任务"}],"id":"93f4851e14fb","title":"5. 达到了，执行饱和策略"}],"id":"0236331c8312","title":"4. 已满，则判断当前线程池的数量有没有到达最大线程数"}],"id":"c8d9a53e3c3d","title":"3. 没有空闲线程，则判断阻塞队列是否已满"}],"id":"092d29d4b49b","title":"2.&nbsp;达到了核心线程数，则判断线程池中有没有空闲线程"}],"id":"3ffa4e958017","title":"1. 判断当前线程数是否达到了核心线程数"}],"id":"a3b292e3eb1c","title":"当一个Runnable或者Callable对象到达线程池时，执行如下策略"},{"parent":"2388bccf20df","note":"public ThreadPoolExecutor(\t\t\t\t\t\t  \n  int corePoolSize,\n  int maximumPoolSize,  \n  long keepAliveTime,\n  TimeUnit unit,                            \n  BlockingQueue&lt;Runnable&gt; workQueue,                            \n  RejectedExecutionHandler handler){\n\n  }\n","children":[{"parent":"fd3c994961f5","children":[],"id":"6e2ba3eccc8c","title":"corePoolSize&nbsp;核心线程池大小"},{"parent":"fd3c994961f5","children":[],"id":"f3e4816096b2","title":"maximunPoolSize&nbsp;最大线程池的数量"},{"parent":"fd3c994961f5","children":[],"id":"592b98d2cea2","title":"keepAliveTime：线程空闲后的存活时间"},{"parent":"fd3c994961f5","children":[],"id":"cf1be894c0ba","title":"unit:空闲线程的存活时间单位"},{"parent":"fd3c994961f5","children":[],"id":"c66d354c769e","title":"workQueue&nbsp;：阻塞队列"},{"parent":"fd3c994961f5","children":[],"id":"eb535a734035","title":"handler&nbsp;饱和策略"}],"id":"fd3c994961f5","title":"手动创建线程池"},{"parent":"2388bccf20df","children":[{"parent":"996e431b34cf","note":"适合于负载较重的服务器或者执行长期作业","children":[],"id":"82c6df3e11b5","title":"Executors.newFixedThreadPool()：固定大小线程池&nbsp;阻塞队列为LinkedBlockingQueue"},{"parent":"996e431b34cf","note":"适合于负载较轻的服务器或执行短期异步小任务，但是若执行速度远小于创建速度，或不断创建线程有可能会内存写满","children":[],"id":"5278a9bf2e9b","title":"Executors.newCashedThreadPool()：无大小限制线程池&nbsp;阻塞队列为SynchronousQueue"},{"parent":"996e431b34cf","children":[],"id":"fe04910cb5a5","title":"Executors.SingleThreadPool()：单线程池、执行顺序任务<br>"},{"parent":"996e431b34cf","children":[],"id":"522e962d4b8f","title":"Executors.ScheduledThreadPool()：定时调度池、阻塞队列为LinkedBlockingQueue，执行定时任务"}],"id":"996e431b34cf","title":"JDK内置四大线程池"}],"collapsed":true,"boundaries":[],"style":{"background-color":"rgb(255, 255, 255)","border-radius":"0px","color":"rgb(51, 51, 51)","border-width":"2px","border-color":"rgb(51, 51, 51)","border-style":"dashed"},"id":"2388bccf20df","title":"线程池"},{"parent":"d78dbc0fbe1e","note":"JDK1.5开始，为了把工作单元与执行机制分离开。Executor框架实现的就是线程池的功","children":[{"parent":"f98358f9dc6d","children":[{"parent":"ff2cfa0921dd","children":[],"id":"df628d284bf0","title":"任务(工作单元)，包括Runnable接口或者Callable接口"},{"parent":"ff2cfa0921dd","children":[],"id":"b03349512e52","title":"任务的执行（把任务分派给多个线程的执行机制），包括Executor接口及其子接口ExecutorService"},{"parent":"ff2cfa0921dd","children":[],"id":"ca936eb22aa2","title":"异步计算的结果：包括Future接口及实现了Future接口的FutureTask类"}],"id":"ff2cfa0921dd","title":"组成部分"},{"parent":"f98358f9dc6d","children":[],"id":"e44d8fc55fcf","title":"使用步骤"}],"collapsed":true,"style":{"background-color":"rgb(255, 255, 255)","border-radius":"0px","color":"rgb(51, 51, 51)","border-width":"2px","border-color":"rgb(51, 51, 51)","border-style":"dashed"},"id":"f98358f9dc6d","title":"Executor框架"},{"parent":"d78dbc0fbe1e","children":[{"parent":"f589268845aa","children":[],"id":"64c8e7ff769a","title":"sleep()&nbsp;线程休眠：调用sleep()方法后线程立马交出CPU，从运行状态转为阻塞状态。方法结束后，从阻塞状态转为就绪状态等待CPU调度、不释放对象锁"},{"parent":"f589268845aa","children":[],"id":"610219c0de0e","title":"yield()&nbsp;线程让步：调用sleep()方法后线程不立马交出CPU，不释放对象锁，只给相同优先级的线程获取CPU的机会。&nbsp;调用yield线程会从运行状态到就绪状态"},{"parent":"f589268845aa","children":[],"id":"59dd4f3a9a48","title":"join()&nbsp;线程等待：当前线程等待别的线程执行完毕再恢复执行，会释放对象锁（底层是wait）调用yield线程会从运行状态到阻塞状态"},{"parent":"f589268845aa","children":[{"parent":"44e3aaed53bf","children":[],"id":"0bd20bb735c3","title":"当线程中有阻塞方法sleep、join、wait时，会抛出中断异常，可以在catch块中处理"},{"parent":"44e3aaed53bf","children":[],"id":"a6629a3829f3","title":"当线程中没有阻塞方法时，只是将中断状态置为true"}],"id":"44e3aaed53bf","title":"interrupted()：将当前线程的状态置为中断状态"},{"parent":"f589268845aa","children":[],"id":"9dea0bbe5227","title":"wait()/notify()&nbsp;notifyAll()&nbsp;线程的等待及唤醒，会释放对象锁，必须在同步代码块中使用"}],"id":"f589268845aa","title":"线程常用方法"},{"parent":"d78dbc0fbe1e","note":"https://www.cnblogs.com/huashuohehe/p/10665733.html","children":[{"parent":"d79d6009b30a","children":[{"parent":"faa5014e3bf5","image":{"w":233,"h":152,"url":"https://cdn2.processon.com/61cc04f8e4b0b85d09419c9a?e=1640764168&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:kaMrstRV3Ut0AlJ3XrGKVywKep8="},"children":[],"id":"f17fb58f2b1b","title":""},{"parent":"faa5014e3bf5","children":[],"id":"390e1fd2e746","title":"底层原理"},{"parent":"faa5014e3bf5","children":[],"id":"e14d587d4c24","title":"优化"}],"id":"faa5014e3bf5","title":"<font color=\"#ff0000\">JVM层面：synchronized关键字</font>"},{"parent":"d79d6009b30a","note":"JDK5中java.util.concurrent.lock包中的Lock对象","children":[{"parent":"5d2bf99240f0","children":[{"parent":"d9622a8d7fcc","children":[],"id":"6effbc18d4ea","title":"互斥&nbsp;共享资源只能被一个线程占有"},{"parent":"d9622a8d7fcc","children":[],"id":"7c0eca27965b","title":"占有且等待&nbsp;线程A已经取得资源X，在等待资源Y的时候不释放X"},{"parent":"d9622a8d7fcc","children":[],"id":"689911bd0014","title":"不可抢占&nbsp;线程A获得X后，其他线程不可抢占X"},{"parent":"d9622a8d7fcc","children":[],"id":"7c08b07da36c","title":"循环等待&nbsp;线程A占有X、线程B占有Y&nbsp;线程A等待Y，线程B等待X"}],"id":"d9622a8d7fcc","title":"死锁的生成充要条件"},{"parent":"5d2bf99240f0","children":[{"parent":"9ea9e1ff5ddf","children":[],"id":"969709bf1383","title":"lockInterruptibly()&nbsp;响应中断"},{"parent":"9ea9e1ff5ddf","children":[],"id":"cb6ea5a890de","title":"trylock(long&nbsp;time,TimeUnit&nbsp;unit)&nbsp;支持超时"},{"parent":"9ea9e1ff5ddf","children":[],"id":"070bc9958067","title":"trylock()&nbsp;非阻塞式获取锁"}],"id":"9ea9e1ff5ddf","title":"解决死锁：破坏任一条件即可"},{"parent":"5d2bf99240f0","children":[],"id":"76ad67108084","title":"Lock较synchronized的优势：支持响应中断、支持超时获取锁、支持非阻塞式获取锁、还可以实现公平锁、支持多个等待队列、支持读写锁"}],"id":"5d2bf99240f0","title":"Java语言层面：Lock锁对象"}],"style":{"background-color":"rgb(255, 255, 255)","border-radius":"0px","color":"rgb(51, 51, 51)","border-width":"2px","border-color":"rgb(51, 51, 51)","border-style":"dashed"},"id":"d79d6009b30a","title":"多线程同步机制"}],"collapsed":true,"id":"d78dbc0fbe1e","title":"多线程"},{"parent":"root","note":"JVM定义了一种Java内存模型来 屏蔽掉各种硬件和操作系统的之间的交互，不像c++中的内存模型，不同的数据类型在不同的平台上长度不一样，Java中不管哪个基本数据类型，在不同的平台上长度都是一模一样的。使得Java程序在各种平台下都能达到一致的内存访问效果\n\nhttps://blog.csdn.net/zhao_miao/article/details/89065615","children":[{"parent":"f86fe63833b0","note":"此处变量：实例字段、静态字段和构成数组对象的元素，但是不包括局部变量和方法参数，因为后两者是私有的，不会被线程共享","children":[],"id":"70055bf39e35","title":"主要目的：<b>定义程序中各个变量的访问规则</b>，即JVM处理将变量存储到内存和从内存中取出变量这样的底层细节"},{"parent":"f86fe63833b0","note":"https://www.cnblogs.com/does/p/13621469.html","children":[{"parent":"fb045ab1b42a","children":[{"parent":"69fc806b496b","children":[],"id":"4c0c09ec0c11","title":"虚拟机栈"},{"parent":"69fc806b496b","children":[],"id":"82555b869455","title":"本地方法栈"},{"parent":"69fc806b496b","children":[],"id":"5cb9704c98ac","title":"程序计数器"}],"id":"69fc806b496b","title":"栈stack"},{"parent":"fb045ab1b42a","children":[],"id":"b10dd30d3b26","title":"堆heap"},{"parent":"fb045ab1b42a","children":[],"id":"a5975af41d4f","title":"方法区method"}],"boundaries":[],"id":"fb045ab1b42a","title":"三个区","summaries":[{"summary":true,"parent":"fb045ab1b42a","children":[],"range":"0,0","style":{"lineType":"curve_complex","lineColor":"#bf1e1b","lineWidth":"1"},"id":"92582608c701","title":"概要"}]},{"parent":"f86fe63833b0","children":[{"parent":"35c8f787ab26","children":[],"id":"fb1603e80e43","title":"所有的变量都存储在主内存中"},{"parent":"35c8f787ab26","children":[],"id":"c3e1c03baf0d","title":"工作内存保存主内存副本拷贝：每条线程还有自己的工作内存，线程的工作内存中保存了&nbsp;被该线程使用到的变量的主内存副本拷贝"},{"parent":"35c8f787ab26","children":[{"parent":"4763daec9312","children":[],"id":"503899fa8044","title":"线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，不能直接读写主内存中的变量"},{"parent":"4763daec9312","children":[],"id":"40692f774c45","title":"主内存桥接：不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成"}],"id":"4763daec9312","title":"各线程只能在自己工作内存操作"}],"id":"35c8f787ab26","title":"主内存和工作内存的基本规定"},{"parent":"f86fe63833b0","note":"规定了主内存和工作内存之间的具体交互协议。通过这8种操作完成\n？？？JVM实现时必须保证下面提及的每一种操作是原子的、不可再分的","children":[{"parent":"2a05dcc86b85","children":[],"id":"a7c0b3b55de6","title":"lock(锁定)：作用于主内存中的变量，它把一个变量标识为一条线程独占的状态"},{"parent":"2a05dcc86b85","children":[],"id":"6e88c4571957","title":"unlock(解锁)：作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。"},{"parent":"2a05dcc86b85","children":[],"id":"a848524a935d","title":"read(读取)：作用于主内存中的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用"},{"parent":"2a05dcc86b85","children":[],"id":"9e290c97a4f7","title":"load(载入)：作用于工作内存中的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中"},{"parent":"2a05dcc86b85","children":[],"id":"9681b419b23a","title":"use(使用)：作用于工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎"},{"parent":"2a05dcc86b85","children":[],"id":"7baa4b2edce8","title":"assign(赋值)：作用于工作内存中的变量，它把一个执行引擎接收到的值赋给工作内存中的变量"},{"parent":"2a05dcc86b85","children":[],"id":"fa379934c355","title":"store(存储)：作用于工作内存中的变量，它把工作内存中一个变量的值送到主内存中，以便后续的write操作使用"},{"parent":"2a05dcc86b85","children":[],"id":"c93ecf227892","title":"write(写入)：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中"}],"id":"2a05dcc86b85","title":"内存间交互操作"},{"parent":"f86fe63833b0","note":"必须满足三大特性，程序才能运行正确","children":[{"parent":"5a20321d1b85","children":[],"id":"81f77f9fb2bf","title":"原子性：指事务的不可分割性，一个事务的所有操作要么不间断地全部被执行，要么一个也没有执行<br>由Java内存模型来<b>直接保证</b>的原子性变量操作包括read、load、assign、use、store、write。大致可以认为<b>基本数据类型的访问读写</b>是具备原子性的，如若需要更大范围的原子性，需要<b><font color=\"#ff0000\">synchronized关键字约束</font></b>。"},{"parent":"5a20321d1b85","children":[],"id":"f3cba1c1cbf0","title":"可见性：指当一个线程修改了共享变量的值，其他线程能够立即知道这个修改。volatile、synchronized、final三个关键字可以实现原子性"},{"parent":"5a20321d1b85","note":"Java内存模型具备一些先天的&quot;有序性&quot;，即不需要通过任何的手段就能够得到保证的有序性，这个通常也称为happens-before原则，如果两个操作的执行次序无法从happens-before原则推导出来，那么就不能保证它们的有序性，虚拟机可以随意的对它们进行重排序","children":[{"parent":"c37052ce7ed8","children":[{"parent":"713e8f139056","children":[],"id":"21895c3a1e12","title":"程序次序原则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作"},{"parent":"713e8f139056","children":[],"id":"2104616a0dc6","title":"锁定规则：unlock解锁操作先行发生于后面对同一个锁的lock加锁操作"},{"parent":"713e8f139056","children":[],"id":"3ebe1c503b10","title":"volatile变量规则：对一个变量的写操作先行发生于后面对这个线程的读操作"},{"parent":"713e8f139056","children":[],"id":"c05483d78b0a","title":"线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作"},{"parent":"713e8f139056","children":[],"id":"d80fcc1c47af","title":"线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生"},{"parent":"713e8f139056","children":[],"id":"a81c7fbe3287","title":"线程终结规则：线程中所有的操作都在线程终止前发生"},{"parent":"713e8f139056","children":[],"id":"f3e2e5132c71","title":"对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始"}],"id":"713e8f139056","title":"happens-before&nbsp;先行发生原则"}],"id":"c37052ce7ed8","title":"有序性：如果在本线程内观察，所有的操作都是有序的，如果在线程中观察另外一个线程，所有的操作都是无序的，前半句是指\"线程内表现为串行\"，后半句是指\"指令重排序\"和\"工作内存与主内存同步延迟\"现象"}],"id":"5a20321d1b85","title":"JVM三大特性"},{"parent":"f86fe63833b0","children":[{"parent":"22fb40db4d0a","note":"当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的","children":[{"parent":"b9110cb3b186","children":[],"id":"66a4e5f19f8b","title":"即volatile变量在各个线程中是一致的"},{"parent":"b9110cb3b186","note":"问题在于num++之中，实际上num++等同于num = num+1，volatile关键字保证了num的值在取值时是正确的，但是在执行num+1的时候，其他线程可能已经把num的值增大了，这样+1之后会把较小的数值同步回主存之中。","children":[{"parent":"98ad11503502","children":[],"id":"45b45aaa97fe","title":"故除了两种情况，还是需要加锁(synchronized或lock)保证原子性<br>两种情况指：<br>1. 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值<br>2. 变量不需要与其它的状态变量共同参与不变约束<br>"}],"id":"98ad11503502","title":"缺陷：volatile变量的运算在并发下同样是不安全的<br>"}],"id":"b9110cb3b186","title":"保证此变量对所有线程的可见性"},{"parent":"22fb40db4d0a","children":[{"parent":"56f47fbe0d25","children":[],"id":"2efc7f1addd8","title":"I/O限制：当程序执行volatile变量的读、写操作时，在其前面的操作肯定全部已经进行完毕，且结果已经对后面的操作可见，在其后面的操作肯定还没有进行"},{"parent":"56f47fbe0d25","children":[],"id":"036c5e3e0f9c","title":"指令优化限制：在进行指令优化时，不能将volatile变量前面的语句放到其后面执行，也不能把volatile变量后面的语句放到其前面执行。"}],"id":"56f47fbe0d25","title":"禁止指令重排序"}],"id":"22fb40db4d0a","title":"volatile型变量的特殊规则"},{"parent":"f86fe63833b0","children":[],"id":"3f4a1d3fc2a2","title":"单例模式中的Double&nbsp;Check双重检验锁模式"}],"collapsed":true,"id":"f86fe63833b0","title":"JVM"},{"parent":"root","children":[{"parent":"79382d1d9e43","children":[{"parent":"d1da02f0000c","children":[{"parent":"15d02c683c42","children":[],"id":"ba6ba20b3006","title":"创建新文件：public&nbsp;boolean&nbsp;createNewFile()&nbsp;throws&nbsp;IOException"},{"parent":"15d02c683c42","children":[],"id":"35887dd904eb","title":"删除文件：public&nbsp;boolean&nbsp;delete()"},{"parent":"15d02c683c42","children":[],"id":"a51749e069ce","title":"路径分隔符：separator"}],"id":"15d02c683c42","title":"文件操作"},{"parent":"d1da02f0000c","children":[{"parent":"2975aac96b1f","children":[],"id":"728410749ed7","title":"取得父路径和父File对象：public&nbsp;String&nbsp;getParent();&nbsp; &nbsp;public&nbsp;File&nbsp;getParentFile();"},{"parent":"2975aac96b1f","children":[],"id":"7581f3e959a6","title":"创建目录（无论有多少级父目录都会一次性创建）：public&nbsp;boolean&nbsp;mkdirs()；"}],"id":"2975aac96b1f","title":"目录操作"},{"parent":"d1da02f0000c","children":[{"parent":"8b86d4792714","children":[],"id":"306bfd8ad7a9","title":"判断路径是否是文件：public&nbsp;boolean&nbsp;isFile();"},{"parent":"8b86d4792714","children":[],"id":"72fe2705128d","title":"取得文件大小：public&nbsp;long&nbsp;length();"},{"parent":"8b86d4792714","children":[],"id":"525473ee7cf6","title":"取得最后修改日期：public&nbsp;long&nbsp;lastModified()"},{"parent":"8b86d4792714","children":[],"id":"1b9f9e6d9f4e","title":"判断路径是否是目录：public&nbsp;boolean&nbsp;isDirectory()"},{"parent":"8b86d4792714","children":[],"id":"2d1c518076ba","title":"列举一个目录的全部组成：public&nbsp;File[]&nbsp;listFile()"}],"id":"8b86d4792714","title":"取得文件或目录信息"},{"parent":"d1da02f0000c","children":[],"id":"7cc5842a1e22","title":"IO的相关处理属于阻塞式耗时操作，一般放在子线程中进行"}],"id":"d1da02f0000c","title":"File类"},{"parent":"79382d1d9e43","children":[{"parent":"25d42e879422","note":"字节流是原生操作，字符流是处理后操作，一般使用字节流，处理中文文本时使用字符流","children":[{"parent":"10f7b3c38139","children":[{"parent":"5a7522977503","children":[{"parent":"d055258f93ae","children":[],"id":"00d35783908b","title":"public&nbsp;abstract&nbsp;class&nbsp;OutputStream&nbsp;implements&nbsp;Closeable,&nbsp;Flushable<br>Closeable：public&nbsp;void&nbsp;close()&nbsp;throws&nbsp;IOException;<br>Flushable:void&nbsp;flush()&nbsp;throws&nbsp;IOException;"},{"parent":"d055258f93ae","children":[{"parent":"468490095e85","children":[],"id":"9e5be4efd822","title":"输出单个字节：public&nbsp;abstract&nbsp;void&nbsp;write(int&nbsp;b)throws&nbsp;IOException;"},{"parent":"468490095e85","children":[],"id":"aec23bbd28ba","title":"将部分字节数组输出：public&nbsp;void&nbsp;write(byte[]&nbsp;b,int&nbsp;offset,int&nbsp;len)throws&nbsp;IOException;"},{"parent":"468490095e85","children":[],"id":"abed17523036","title":"将指定的字节数组全部输出：public&nbsp;void&nbsp;write(byte[]&nbsp;b)throws&nbsp;IOException;&nbsp;"}],"id":"468490095e85","title":"write方法"},{"parent":"d055258f93ae","note":"当使用FileOutoutStream进行文件内容输出时，只要文件的父路径存在，FileOutputStream会自动创建文件","children":[{"parent":"c18f692a4088","children":[],"id":"54d44b6bc09e","title":"文件内容的覆盖：public&nbsp;FileOutputStream(File&nbsp;file)&nbsp;throws&nbsp;FileNotFoundException"},{"parent":"c18f692a4088","children":[],"id":"d28d270aaf7f","title":"文件内容的追加：public&nbsp;FileOutputStream(File&nbsp;file,&nbsp;boolean&nbsp;append)throws&nbsp;FileNotFoundException"}],"id":"c18f692a4088","title":"子类FileOutputStream：文件内容的输出"}],"id":"d055258f93ae","title":"OutputStream"},{"parent":"5a7522977503","children":[{"parent":"dfe3d4c77ab8","children":[],"id":"dd2a222f6620","title":"public&nbsp;abstract&nbsp;class&nbsp;InputStream&nbsp;implements&nbsp;Closeable&nbsp;<br>Closeable：public&nbsp;void&nbsp;close()&nbsp;throws&nbsp;IOException;"},{"parent":"dfe3d4c77ab8","children":[{"parent":"fafd23b9959f","note":"  1.返回b的长度：当被读取的数据大小&gt;字节数组大小 返回字节数组大小\n    2.返回一个大于0的数但是小于b长度： 被读取的数据大小&lt;字节数组大小 返回真正读取的个数\n    3.返回-1： 数据读取完毕\n\n    可以将被读取的数据看作稀饭,将字节数组的大小看作勺子","children":[],"id":"d73a110e8109","title":"读取数据到字节数组b中：public&nbsp;int&nbsp;read(byte&nbsp;b[])&nbsp;throws&nbsp;IOException;&nbsp;"},{"parent":"fafd23b9959f","children":[],"id":"b9d3cd0fa76e","title":"读取单个字节：public&nbsp;abstract&nbsp;int&nbsp;read()&nbsp;throws&nbsp;IOException;"}],"id":"fafd23b9959f","title":"常用方法"}],"id":"dfe3d4c77ab8","title":"InputStream"}],"id":"5a7522977503","title":"字节流byte"},{"parent":"10f7b3c38139","children":[{"parent":"5968946931a3","children":[{"parent":"49364b47bc96","children":[],"id":"4dadcf894057","title":"其他三个几乎同OutputStream的write()"},{"parent":"49364b47bc96","children":[],"id":"2ef35b7a3143","title":"public&nbsp;void&nbsp;write(String&nbsp;str)&nbsp;throws&nbsp;IOException"}],"id":"49364b47bc96","title":"Writer"},{"parent":"5968946931a3","children":[{"parent":"2deb593516c0","children":[],"id":"eb82f7a8ce29","title":"无直接读取字符串方法，只能通过字符数组读取：public&nbsp;int&nbsp;read(char&nbsp;b[])&nbsp;throws&nbsp;IOException"}],"id":"2deb593516c0","title":"Reader"}],"id":"5968946931a3","title":"字符流char"},{"parent":"10f7b3c38139","children":[{"parent":"db4cdec9dd50","children":[],"id":"cf63dd6d99bf","title":"字节流优先考虑，只有处理中文才考虑字符流"},{"parent":"db4cdec9dd50","children":[],"id":"9062c8a09314","title":"所有字符流操作，无论是写入还是输出，数据都先保存在缓存中，如果不关闭流，则数据不会写入或者读出"}],"id":"db4cdec9dd50","title":"实际开发<br>"},{"parent":"10f7b3c38139","children":[{"parent":"268b7ac10f83","children":[],"id":"f76ef40f2a38","title":"OutputStreamWriter:字节输出流---&gt;字符输出流"},{"parent":"268b7ac10f83","children":[],"id":"282986fbbf20","title":"InputStreamReader：字节输入流---&gt;字节输出流"}],"id":"268b7ac10f83","title":"转换流"}],"id":"10f7b3c38139","title":"流分类","summaries":[]},{"parent":"25d42e879422","note":"1. 无论字节流还是字符流，操作流程几乎一样，以操作文件为例\n2. IO操作属于资源处理，所有资源处理（IO、数据库、网络）使用后都必须关闭","children":[{"parent":"799ad30f7180","children":[],"id":"6bb8db884ecb","title":"1.取得File对象"},{"parent":"799ad30f7180","children":[],"id":"8def3eb955b9","title":"2.取得File对象的输入、输出流"},{"parent":"799ad30f7180","children":[],"id":"e64752929bca","title":"3.进行数据的读取或写入"},{"parent":"799ad30f7180","children":[],"id":"43b6e5c1a5e1","title":"4.关闭流（close）"}],"id":"799ad30f7180","title":"流的操作过程"},{"parent":"25d42e879422","children":[],"id":"b385e7ae099e","title":"文件拷贝算法"}],"id":"25d42e879422","title":"IO类"}],"collapsed":false,"id":"79382d1d9e43","title":"File与IO类","tags":[{"color":"#fff","background":"rgba(255,159,26,1)","text":"做了题目后看看需不需要实践巩固"}]},{"parent":"root","children":[{"parent":"433db8b90b85","children":[{"parent":"b0de96a559a5","children":[{"parent":"b82f6cfefd6f","note":"为什么要有端口号？\n  告诉将来连接服务器的客户端我是哪个端口号\n    进程id用来标识唯一的进程\n    端口号也用来标识唯一的网络进程","children":[],"id":"2ae7a9eaf30c","title":"ServerSocket&nbsp;server&nbsp;=&nbsp;new&nbsp;ServerSocket(port);<br>传入端口号，建立服务端Socket等待客户连接，通过构造方法建立基站"},{"parent":"b82f6cfefd6f","children":[],"id":"a479101c6e88","title":"public&nbsp;Socket&nbsp;<b>accept()</b>&nbsp;throws&nbsp;IOException;<br>等待客户端连接<br>"},{"parent":"b82f6cfefd6f","children":[],"id":"5791ecc1a820","title":"取得输入输出流，进行通信"},{"parent":"b82f6cfefd6f","children":[],"id":"ca23826b5372","title":"关闭流&nbsp;(关闭基站)"}],"id":"b82f6cfefd6f","title":"步骤"},{"parent":"b0de96a559a5","children":[{"parent":"c4519a7a3a03","children":[],"id":"8440028ee079","title":"构造方法，建立服务端的基站，并且绑定端口号为port：public&nbsp;ServerSocket(int&nbsp;port)&nbsp;throws&nbsp;IOException<br>"},{"parent":"c4519a7a3a03","children":[],"id":"7736cf862d93","title":"服务器启动之后一直阻塞直到有客户端连接：public&nbsp;Socket&nbsp;<b>accept()&nbsp;</b>throws&nbsp;IOException;"}],"id":"c4519a7a3a03","title":"常用API"}],"id":"b0de96a559a5","title":"服务端Socket类&nbsp;：ServerSocket"},{"parent":"433db8b90b85","children":[{"parent":"bb2ab16bbc49","children":[{"parent":"1deed6c7cc45","children":[],"id":"e360ab69a5bc","title":"连接到指定服务器，通过构造方法实现\nSocket&nbsp;client&nbsp;=&nbsp;new&nbsp;Socket(ip,port);"},{"parent":"1deed6c7cc45","children":[],"id":"b2b10fddcd88","title":"取得输入输出流<br>getInputStream()<br>getOutputStream()"},{"parent":"1deed6c7cc45","children":[],"id":"ecf95b2ab9d5","title":"关闭流 close()"}],"id":"1deed6c7cc45","title":"步骤"},{"parent":"bb2ab16bbc49","children":[{"parent":"23b2262cd16a","children":[],"id":"520e0e7d3f4a","title":"构造方法，传入服务器的主机IP和服务器基站端口号：public&nbsp;Socket&nbsp;(String&nbsp;host,int&nbsp;port)throws&nbsp;UnknownHostException,IOException"},{"parent":"23b2262cd16a","children":[],"id":"cea15ddcb6ee","title":"返回此套接字的输入流：public&nbsp;InputStream&nbsp;getInputStream()&nbsp;throws&nbsp;IOException"},{"parent":"23b2262cd16a","children":[],"id":"285e3374c05f","title":"返回此套接字的输出流：public&nbsp;OutputStream&nbsp;getOutputStream()&nbsp;throws&nbsp;IOException"},{"parent":"23b2262cd16a","children":[],"id":"eb527a42d49e","title":"另一端的端口号：public&nbsp;int&nbsp;getPort();"},{"parent":"23b2262cd16a","children":[],"id":"6f371d1cbef2","title":"自己的端口号：public&nbsp;int&nbsp;getLocalPort();"},{"parent":"23b2262cd16a","children":[],"id":"c8358151817e","title":"关闭此套接字&nbsp;客户端连接请求的发起与客户端Socket的关闭都在客户端进行：public&nbsp;void&nbsp;close()throws&nbsp;IOException"}],"id":"23b2262cd16a","title":"常用API"}],"id":"bb2ab16bbc49","title":"客户端Socket类&nbsp;：Socket"}],"collapsed":true,"id":"433db8b90b85","title":"网络通信"},{"parent":"root","children":[{"parent":"b6dfedf33e5c","children":[],"id":"93ee03dbd4f5","title":"JDBC：java数据库连接 Java&nbsp;DataBase&nbsp;Connectivity"},{"parent":"b6dfedf33e5c","children":[{"parent":"2b2ce4cf443f","children":[],"id":"23692594690e","title":"应用层：程序员开发——J2EE应用"},{"parent":"2b2ce4cf443f","children":[],"id":"4684452a9d02","title":"JDBC接口层：Sun——JDBC&nbsp;API"},{"parent":"2b2ce4cf443f","children":[],"id":"674b653db887","title":"JDBC驱动层：数据库厂商——&gt;数据库JDBC驱动程序、数据库"}],"id":"2b2ce4cf443f","title":"JDBC访问数据库层次结构"},{"parent":"b6dfedf33e5c","image":{"w":414,"h":285,"url":"https://cdn2.processon.com/61cbf180e4b053ea69c3279c?e=1640759184&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:qYsasthTry8vXEYdP2tdkNKQeOU="},"children":[{"parent":"904e8fd663fc","children":[],"id":"867375eb7a8f","title":"加载数据库驱动，并将其注册到DriverManager中，一般使用反射Class.forName(String&nbsp;dirverName)"},{"parent":"904e8fd663fc","children":[],"id":"ee1eef68c4d4","title":"建立数据库连接，取得Connection对象，一般通过DriverManager.getConnection(url，username，password)方法实现，其中url表示连接数据库的字符串、username表示连接数据库的用户名，password表示连接数据库的密码"},{"parent":"904e8fd663fc","children":[],"id":"607ba7bd172d","title":"建立Statement对象或者PreparedStatement对象"},{"parent":"904e8fd663fc","children":[],"id":"e38d3ee75f4f","title":"执行SQL语句"},{"parent":"904e8fd663fc","children":[],"id":"c851fc07b4c5","title":"访问结果集ResultSet对象"},{"parent":"904e8fd663fc","children":[],"id":"42130fb50718","title":"依次将ResultSet、Statement、PreparedStatement、Connection对象关闭，释放掉所占用的资源"}],"id":"904e8fd663fc","title":"JDBC使用路程图"},{"parent":"b6dfedf33e5c","note":"在Java JDBC编程中对 数据库的操作 均使用JDK自带的API统一处理，通常与特定数据库的驱动类是完全解耦的，所以掌握Java JDBC API（位于java.sql包下）即可掌握Java数据库编程","children":[{"parent":"67d09dd63678","children":[{"parent":"de1223f27365","children":[],"id":"26dca8daf503","title":"通过DriveManager的静态方法获取"},{"parent":"de1223f27365","children":[],"id":"5bfc8492ae5d","title":"通过DataSource(数据源)对象获取"}],"id":"de1223f27365","title":"数据库连接"},{"parent":"67d09dd63678","children":[{"parent":"5115fca33c4f","children":[],"id":"8db14c6b147f","title":"Statement：用于执行不带参数的简单SQL语句"},{"parent":"5115fca33c4f","note":"最常用\n优点分析\n1. 效率更高，执行插入、删除、更新等操作最好使用它\n2.代码的可读性和维护性更好。\n3.安全性更好。使用PreparedStatement能够预防SQL注入（SQL注入指的是通过把SQL命令 插入到Web表单递交 或输入域名 或页面请求的查询字符串，最终达到欺骗服务器，达到恶意执行SQL命令的目的）","children":[{"parent":"9bffde567b5a","children":[],"id":"9860c77c5516","title":"用于执行带或不带参数的SQL语句"},{"parent":"9bffde567b5a","children":[],"id":"186c286689ad","title":"SQL语句会预编译在数据库系统"},{"parent":"9bffde567b5a","children":[],"id":"413563b6f861","title":"执行速度快于Statement"}],"id":"9bffde567b5a","title":"PreparedStatement"},{"parent":"5115fca33c4f","children":[{"parent":"a73dde637ca2","children":[],"id":"4b6ad53e079a","title":"执行数据库存储过程的调用"}],"id":"a73dde637ca2","title":"CallableStatement"},{"parent":"5115fca33c4f","children":[{"parent":"ba4af2d28b70","children":[],"id":"abe3345aafb6","title":"executeQuery()方法执行后返回单个结果集，通常用于select"},{"parent":"ba4af2d28b70","children":[],"id":"db05fd067b4b","title":"executeUpdate()方法返回值是一个整数，通常用于update、insert"}],"id":"ba4af2d28b70","title":"主要掌握的执行SQL的方法"}],"id":"5115fca33c4f","title":"Statement对象"},{"parent":"67d09dd63678","children":[{"parent":"45f90dd2032b","note":"ResultSet里的数据一行一行排列，每行有多个字段，并且有一个记录指针，指针所指向的数据行叫做当前数据行，我们只能来操作当前的数据行。我们如果想要取得某一条记录，就要使用ResultSet的next()方法，如果我们想要得到ResultSet里的所有记录，就应该使用while循环","children":[],"id":"66c0433cdb19","title":"结果集，它代表符合SQL语句条件的所有行，并且它通过一套get×××方法提供了对这些行中数据的访问"}],"id":"45f90dd2032b","title":"ResultSet对象"}],"id":"67d09dd63678","title":"JDBC常用接口和类"}],"collapsed":true,"id":"b6dfedf33e5c","title":"数据库编程JDBC"}],"root":true,"theme":"theme3","id":"root","title":"JavaSE Review","lines":{"272063c30fb4":{"realEnd":{"x":10359.499805157,"y":10437.833251953125},"start":{"x":"0.5","y":"1.0","index":4},"angle":266.51031543303577,"styles":{"color":"#ffffff","lineColor":"rgb(113, 203, 45)","lineWidth":2},"from":"2388bccf20df","end":{"x":"0.5","y":"0.0","index":1},"id":"272063c30fb4","realStart":{"x":10329.999805157,"y":9954.083237868088},"to":"f98358f9dc6d","points":[]}},"version":49,"structure":"mind_free"}},"meta":{"exportTime":"2024-07-30 21:32:00","member":"","diagramInfo":{"creator":"","created":"","modified":"","title":"","category":""},"id":"","type":"ProcessOn Schema File","version":"1.0"}}